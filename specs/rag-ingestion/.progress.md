---
spec: rag-ingestion
phase: research
task: 0/0
updated: 2026-01-14T00:00:00Z
---

# Progress: rag-ingestion

## Original Goal

I want to use llamaindex python, HF TEI with qwen 3 0.6B, and qdrant to create a RAG pipeline. It should watch a folder for any markdown files, automatically generate embeddings (1024 vector dims) and store in qdrant

## Completed Tasks

1. ✅ Research phase - Analyzed LlamaIndex, TEI, Qwen3, Qdrant, watchdog libraries
2. ✅ Requirements phase - Generated 12 user stories, 18 FRs, 12 NFRs with priorities
3. ✅ Specification review - Identified 30 issues (3 critical, 7 ambiguities, 16 gaps, 4 technical)
4. ✅ Decision phase - Resolved all 30 issues with user input via AskUserQuestion
5. ✅ Requirements update - Updated requirements.md with all resolved specifications
6. ✅ Technical review - Validated all architectural decisions, integration approaches, and performance targets
7. ✅ Task 1.1.1: Create project structure - bc07851
8. ✅ Task 1.1.2: Initialize pyproject.toml - pending commit
9. ✅ Task 1.1.3: Create .env.example and .gitignore - 8643d71
10. ✅ Task 1.2.1: [RED] Write failing tests for configuration validation - b31465a
11. ✅ Task 1.2.2: [GREEN] Implement configuration module to pass tests - 315800a
12. ✅ Task 1.2.3: [REFACTOR] Add type hints and docstrings to config module - dd6105f
13. ✅ Task V1: [VERIFY] Quality checkpoint after config module - 1374782
14. ✅ Task 1.3.1: [RED] Write failing tests for structured logging - 25b0797
15. ✅ Task 1.3.2: [GREEN] Implement logger module to pass tests - aaf7416
16. ✅ Task 1.3.3: [REFACTOR] Add type hints and improve logger configuration - fbd4d4e

## Current Task

Task 1.3.3 complete - awaiting next task (V2 [VERIFY])

## Key Decisions (from Specification Review)

### Architecture
- **File paths**: Store BOTH relative and absolute in metadata for portability + convenience
- **Point IDs**: SHA256 hash of file_path_relative:chunk_index → UUID format
- **TEI endpoint**: Use /embed (native TEI endpoint)
- **TEI integration**: Custom BaseEmbedding class inheriting from LlamaIndex BaseEmbedding
- **Batch strategy**: Process 10-50 documents at a time, embed all chunks per document
- **State tracking**: Query Qdrant on startup for existing files, compare modification dates

### Configuration
- **Container hostnames**: TEI=http://crawl4r-embeddings:80, Qdrant=http://crawl4r-vectors:6333
- **Collection name**: "crawl4r" (matches docker-compose project name)
- **WATCH_FOLDER**: Required (no default) - must be explicitly configured
- **Chunk overlap**: Fixed at 15% (77 tokens for 512-token chunks)
- **Max concurrent docs**: 10 (balanced for RTX 3050)
- **Queue max size**: 1000 items with backpressure
- **Environment configs**: Provide .env.dev and .env.prod example templates

### Metadata Schema
- **Core**: file_path_relative, file_path_absolute, filename, modification_date, chunk_index, chunk_text
- **Structure**: section_path (filename if no headings), heading_level (0-6)
- **Optional**: tags (array from frontmatter, skip invalid YAML gracefully)
- **Qdrant indexes**: file_path_relative, filename, modification_date, tags (all keyword/datetime)

### Operational Behavior
- **Queue overflow**: Backpressure - pause watcher at 1000 items, resume at 800
- **Retry failures**: Log to failed_documents.jsonl and skip after 3 attempts (1s, 2s, 4s)
- **Circuit breaker**: Queue events during outage, process when circuit closes
- **Startup validation**: Retry TEI/Qdrant 3 times (5s, 10s, 20s), exit on failure
- **Watchdog exclusions**: Ignore .git, .*, __pycache__, node_modules, venv, dist, build, no symlinks
- **Logging**: Human-readable format for dev, rotating files (100MB, 5 backups)
- **Memory budget**: <4GB (revised from <2GB)
- **Chunk text storage**: Store full text in payload (accept 2-3GB for 1M vectors)

### Out of Scope
- Health check HTTP endpoint (FR-15) - deferred
- JSON structured logging - using human-readable for now
- Normalization checks - pending Qwen3 research

## Requirements Clarifications (Original)

1. **Chunking**: Start with markdown-aware chunking for technical documentation
2. **Initial Loading**: Process existing files on startup with batch processing support
3. **Updates**: Delete old vectors and re-ingest on modification; auto-cleanup on deletion
4. **Performance**: Handle thousands of files, few minutes latency, non-blocking with queuing
5. **Deployment**: Local servers with RTX 3050 GPU (dev) / RTX 4070 (prod), up to 1M vectors
6. **Metadata**: Store filename, modification date, tags, file path, full document retrieval support, filtering/searching
7. **Quality**: Sample-based verification, dimension validation, vector normalization checks

## Learnings

- Task 1.1.1 completed successfully - all directory structure and init files created as specified
- Qwen3-Embedding-0.6B supports Multi-Representation Learning (MRL), allowing custom dimensions from 32-1024 without retraining
- TEI's OpenAI-compatible `/v1/embeddings` endpoint supports a `dimensions` parameter for custom output sizes
- LlamaIndex doesn't have native TEI integration - will need custom embedding class using OpenAI-compatible endpoint or InferenceClient
- Watchdog requires debouncing (1-second threshold recommended) to prevent duplicate processing from rapid file events
- Markdown-aware chunking by headings is best practice for markdown documents, preserving semantic structure
- All major components (LlamaIndex, TEI, Qdrant) support async operations for better performance
- This is a greenfield project - no existing patterns or technical debt to work around
- TEI volume mounting recommended to avoid re-downloading 0.6B model weights on each container restart
- **CLARIFICATION**: `transformers >= 4.51.0` is NOT needed for our application - only required if loading Qwen3 directly in Python. TEI Docker container handles all model dependencies internally
- Actual Python dependencies: llama-index-core, llama-index-vector-stores-qdrant, llama-index-readers-file, qdrant-client, watchdog, huggingface-hub
- Requirements phase revealed 12 distinct user stories spanning full document lifecycle (startup batch, real-time watch, modification, deletion)
- Vector lifecycle management is critical: must delete old vectors before re-ingestion to prevent duplicates
- Deterministic point IDs (hash of file_path + chunk_index) enable idempotent operations for crash recovery
- Metadata richness directly impacts query flexibility: file_path, modification_date, chunk_text, section_path, tags all required
- Circuit breaker pattern essential for handling TEI/Qdrant outages without cascading failures
- Performance targets validated against hardware specs: 50-100 docs/min on RTX 3050, 100-200 on RTX 4070
- Quality verification requires multi-level checks: startup validation, per-request dimension checks, sampling-based normalization
- Configuration management complexity spans 12+ parameters across chunking, performance, and service endpoints
- **TECHNICAL REVIEW**: Custom BaseEmbedding class pattern is officially supported by LlamaIndex with clear implementation guidance
- **TECHNICAL REVIEW**: Qwen3 embeddings ARE L2-normalized (unit vectors with norm = 1.0), validation should use ±0.01 tolerance
- **TECHNICAL REVIEW**: SHA256→UUID truncation is safe (128-bit collision resistance sufficient), but store full hash in payload for verification
- **TECHNICAL REVIEW**: Timer-based debouncing with threading.Timer is industry standard pattern for watchdog implementations
- **TECHNICAL REVIEW**: LlamaIndex MarkdownNodeParser defaults to 1024 token chunks - must override to 512 with 77-token overlap
- **TECHNICAL REVIEW**: Qdrant payload indexing is CRITICAL at scale - must index file_path_relative, filename, modification_date, tags
- **TECHNICAL REVIEW**: Performance targets (50-100 docs/min) are realistic with proper batching and async processing
- **TECHNICAL REVIEW**: 4GB memory budget is adequate for specified workload but not generous - monitor actual usage
- **TECHNICAL REVIEW**: Startup recovery via Qdrant scroll may take 10-30 seconds for 1M vectors - acceptable with progress logging
- **Version Update (Jan 2026)**: LlamaIndex now at v0.14.12, TEI at v1.8.3, Qdrant client at v1.16.2, watchdog at v6.0.0 - all more mature and stable
- **Python Version Constraint**: Qdrant client requires Python 3.10+ (more restrictive than LlamaIndex's 3.9+) - sets project minimum
- **llama-index-vector-stores-qdrant**: Very actively maintained (v0.9.1 released Jan 13, 2026)
- **Hybrid Search Option**: Qdrant v1.16+ includes built-in BM25 without FastEmbed dependency - consider for enhanced retrieval
- **TEI Stability**: v1.8.3 bug fixes include infinite loop resolution, error code handling - production-ready
- **RAG Chunking Consensus (2025-2026)**: Header-based splitting for markdown confirmed as industry best practice, recursive chunking with 512 tokens + 10-20% overlap standard
- **Research Verification (Jan 14, 2026)**: All 28 source URLs validated, 10/10 technical claims verified, 100% accuracy - research document approved for use with minor version updates
- **DESIGN PHASE**: Component architecture requires 8 primary modules: config, watcher, processor, embeddings, vector_store, queue_manager, quality, logger
- **DESIGN PHASE**: Pydantic BaseSettings provides type-safe configuration with validation at 20+ parameters across service endpoints, chunking, performance, retry logic, and logging
- **DESIGN PHASE**: Circuit breaker state machine (CLOSED→OPEN→HALF_OPEN) with queue-based event buffering prevents cascading TEI/Qdrant failures while preserving all events
- **DESIGN PHASE**: AsyncIO Queue with backpressure (pause at 1000, resume at 800) coordinates file watcher and document processor without blocking
- **DESIGN PHASE**: Full metadata schema includes content_hash field for SHA256 verification beyond truncated UUID point IDs
- **DESIGN PHASE**: Integration testing requires isolated test collection with cleanup, measuring throughput benchmarks against 50+ docs/min target
- **DESIGN PHASE**: Docker Compose configuration uses high ports (52000, 52001, 52002) matching actual deployment, GPU support for TEI, persistent volumes for model cache and Qdrant storage
- **TASK PLANNING**: POC-first workflow with 4 phases: (1) Make It Work - validate core functionality, (2) Refactoring - async conversion and error handling, (3) Testing - comprehensive coverage, (4) Quality Gates - CI/CD and documentation
- **TASK PLANNING**: 47 total tasks across all phases with quality checkpoints every 2-3 tasks to catch issues early
- **TASK PLANNING**: Phase 1 (POC) has 19 tasks focusing on end-to-end validation: setup → TEI → Qdrant → chunking → watching → batch processing
- **TASK PLANNING**: Phase 2 (Refactoring) has 13 tasks for production readiness: async conversion, queue/backpressure, circuit breaker, state recovery, enhanced metadata
- **TASK PLANNING**: Phase 3 (Testing) has 11 tasks for comprehensive coverage: 6 unit test modules, 3 integration tests, 2 e2e/performance tests targeting 85%+ coverage
- **TASK PLANNING**: Phase 4 (Quality Gates) has 4 tasks: local verification, documentation, CI/CD, and 13 AC verification checkpoints (V21-V33) covering all 12 user stories
- **TASK PLANNING**: Critical dependency: uv for package management (NOT pip, poetry, pipenv) per project standards and Python 3.10+ requirement
- **TASK PLANNING**: Quality commands discovered from research.md: ruff (lint/format), ty (typecheck), pytest (test/coverage)
- **TASK PLANNING**: POC shortcuts documented for cleanup: synchronous processing, no queue initially, basic error handling, simple logging - all addressed in Phase 2
- **TASK PLANNING**: Each task includes exact file paths, verification commands, and traceability to requirements/design sections for autonomous execution
- **TASK PLANNING CORRECTION**: Updated tasks.md to remove src/ directories per CLAUDE.md standards - code directly in rag_ingestion/ package folder (93 references corrected)
- **TASK PLANNING CORRECTION**: Replaced mypy with ty (Astral's extremely fast Python type checker) per project preference - updated CLAUDE.md, tasks.md, and all spec files (43+ references)
- **TASK PLANNING CORRECTION**: Configured all tools (ruff, ty, pytest, coverage) in pyproject.toml with centralized `.cache/` directory instead of separate cache folders (.ruff_cache, .ty_cache, .pytest_cache) - ensures clean project root
- **TASK PLANNING CORRECTION**: Enabled strict type checking: ty configured with strict=true, disallow_any_explicit=true, disallow_untyped_defs=true - NO any types allowed
- **TASK PLANNING (2026-01-14)**: Created 78 TDD-compliant tasks across 9 phases with strict RED-GREEN-REFACTOR methodology enforced in every task
- **TASK PLANNING**: 41 verification tasks (V1-V41) including 16 quality checkpoints every 2-3 tasks to catch issues early, plus 25 final verification tasks for AC validation
- **TASK PLANNING**: Phase organization: (1) Core Infrastructure - config/logging, (2) TEI Integration - embeddings/circuit breaker, (3) Qdrant - storage/lifecycle, (4) Document Processing - chunking/frontmatter, (5) File Watching - debouncing/exclusions, (6) State Recovery - startup validation, (7) Integration Testing - e2e tests, (8) Quality Gates - coverage/AC verification, (9) Final Deliverable - PR creation
- **TASK PLANNING**: TDD compliance ensures NO implementation without failing tests first - each feature has 3-task cycle (RED test → GREEN implementation → REFACTOR improvement)
- **TASK PLANNING**: Integration tests require isolated test collections with cleanup, real service endpoints (TEI at :52000, Qdrant at :52001/52002), and pytest.mark.skipif for service unavailability
- **TASK PLANNING**: Quality checkpoints use discovered commands from research.md: ruff check, ty check with strict mode, pytest with coverage >= 85% target
- **TASK PLANNING**: Acceptance criteria verification tasks (V21-V33) map all 12 user stories with 13 detailed AC checklists covering 70+ individual acceptance criteria points
- **TASK PLANNING**: Performance validation tasks (V36-V38) verify NFR targets: 50+ docs/min throughput, <5s latency, <4GB memory - measurable benchmarks required
- **TASK PLANNING**: Documentation tasks include comprehensive README (100+ lines), .env.example with all parameters, Google-style docstrings for all public APIs
- **TASK PLANNING**: Key architecture decisions embedded in tasks: deterministic UUID point IDs (SHA256), payload indexing for metadata fields, circuit breaker with queue buffering, debouncing with threading.Timer
- **TASK PLANNING**: Task dependencies identified: pyproject.toml must precede all implementation, config module required before any component initialization, startup validation blocks watch mode
- **TASK PLANNING**: Risk mitigation in tasks: failed document logging after 3 retries (1s, 2s, 4s), circuit breaker for TEI/Qdrant outages, state recovery via Qdrant scroll on restarts
- **TASK PLANNING**: Tool configuration centralized in pyproject.toml with .cache/ directory for all artifacts (ruff, ty, pytest, coverage) - keeps project root clean per CLAUDE.md standards
- **TASK 1.1.3**: Created .env.example with 47 lines of comprehensive documentation including all 11 configuration parameters with defaults and descriptions
- **TASK 1.1.3**: Updated .gitignore to match task requirements - covers .env, .cache/, Python artifacts, coverage, logs, and failed_documents.jsonl
- **TASK 1.2.1**: TDD RED phase completed - created comprehensive test suite covering config loading, validation, defaults, and type checking
- **TASK 1.2.1**: All tests fail correctly with ModuleNotFoundError (no implementation exists yet) - this is expected and correct for RED phase
- **TASK 1.2.1**: Test structure includes 6 test classes covering: loading from env, validation rules (required fields, ranges, positive integers), default values, and type conversion
- **TASK 1.2.2**: TDD GREEN phase completed - implemented Settings class with Pydantic BaseSettings and all validation rules
- **TASK 1.2.2**: Added pydantic-settings dependency to pyproject.toml (was missing from initial setup)
- **TASK 1.2.2**: All 7 tests pass (RED → GREEN): config loading, validation (required fields, overlap range, positive integers), defaults, type conversion
- **TASK 1.2.2**: Field validators implemented using @field_validator decorator with comprehensive error messages
- **TASK 1.2.2**: Settings class includes comprehensive docstrings in Google format with Args, Returns, Raises sections per project standards
- **TASK 1.2.3**: Fixed pyproject.toml ty configuration - ty requires specific structure with [tool.ty.environment], [tool.ty.src], and [tool.ty.rules] sections (not flat config)
- **TASK 1.2.3**: Enhanced type hints on validators with explicit `cls: type["Settings"]` parameter type for better type checking
- **TASK 1.2.3**: Added inline comments to explain validation logic and business rationale (e.g., overlap limits, concurrency tradeoffs, batch sizing for GPU memory)
- **TASK 1.2.3**: Added Examples sections to module and class docstrings demonstrating actual usage patterns
- **TASK 1.2.3**: Changed "Args" to "Attributes" in Settings class docstring (Google-style convention for class attributes vs function args)
- **TASK V1**: Quality checkpoint passed - ruff, ty, and pytest all passed with minimal fixes
- **TASK V1**: Added ruff exclusion for scripts/ folder in pyproject.toml to avoid linting non-package code
- **TASK V1**: Auto-fixed unused import issues (typing.Any) in config.py and test_config.py using ruff --fix
- **TASK 1.3.1**: TDD RED phase completed for logger module - created test suite with 6 test classes covering handler creation, formatting, log levels, file output, and config integration
- **TASK 1.3.1**: All tests fail correctly with ModuleNotFoundError (no implementation exists yet) - this is expected and correct for RED phase
- **TASK 1.3.1**: Test structure includes comprehensive coverage: console handler (INFO level), rotating file handler (100MB, 5 backups), human-readable format (timestamp, level, module, message), log level enforcement (DEBUG/INFO/WARNING/ERROR), custom file paths, directory creation
- **TASK 1.3.2**: TDD GREEN phase completed - implemented get_logger() function with all required features
- **TASK 1.3.2**: All 7 tests pass (RED → GREEN): console handler, rotating file handler (100MB, 5 backups), human-readable format, log level enforcement, custom log file paths, directory creation
- **TASK 1.3.2**: Implementation includes logger.handlers.clear() to allow reconfiguration - important for testing and when log_file changes between calls
- **TASK 1.3.2**: Rotating file handler logs at DEBUG level (captures everything), console handler at INFO level (user-facing output)
- **TASK 1.3.3**: REFACTOR phase completed - extracted constants (LOG_FORMAT, DEFAULT_LOG_FILE, MAX_LOG_SIZE_BYTES, BACKUP_COUNT) to improve maintainability
- **TASK 1.3.3**: Enhanced docstrings with comprehensive Args, Returns, Raises sections following Google-style format
- **TASK 1.3.3**: Added module-level and function-level examples to demonstrate usage patterns
- **TASK 1.3.3**: All type hints already present from GREEN phase, strict ty checking passes with NO any types

## Infrastructure Status (2026-01-15)

✅ **All Services Operational**:
- `crawl4r-embeddings` (TEI): Ready on port 52000, Qwen3-Embedding-0.6B model loaded (1.19GB cached)
- `crawl4r-vectors` (Qdrant): Running on ports 52001 (HTTP), 52002 (gRPC)
- `crawl4r-db` (PostgreSQL): Running on port 53432
- `crawl4r-cache` (Redis): Running on port 53379
- `crawl4ai`: Running on port 52004 (312 MiB RAM, 100 MiB shm usage)

**Network**: Docker bridge `crawl4r` (172.20.0.0/16) with DNS resolution confirmed
**GPU**: CUDA available, RTX 3050 8GB configured for TEI
**Model Cache**: `/home/jmagar/appdata/crawl4r-embeddings/models--Qwen--Qwen3-Embedding-0.6B/`

## Blockers

- None currently

## Next

✅ All specifications finalized and documented
✅ 30 issues resolved with architectural decisions captured in decisions.md
✅ requirements.md updated with resolved specifications
✅ Technical review completed - all decisions validated, no blocking issues

**Status**: APPROVED for design phase
**Confidence**: HIGH (85%)
**Key Findings**:
- Custom BaseEmbedding pattern is officially supported and well-documented
- SHA256→UUID truncation is safe but add full hash to payload
- Qwen3 embeddings are L2-normalized (use ±0.01 tolerance for checks)
- Performance targets (50-100 docs/min) are realistic with proper batching
- 4GB memory budget is adequate but monitor actual usage
- Qdrant payload indexing is critical - must index file_path_relative, filename, modification_date, tags

**Minor Recommendations for Design Phase**:
- Add content_hash field to metadata for integrity verification
- Include file size limits (default 10MB) and binary file detection
- Add disk space checks to startup validation
- Document docker-compose.yml configuration
- Create config validation with Pydantic BaseSettings
- Define integration testing strategy

**Ready to proceed**: Run /ralph-specum:design to generate technical design
